options {
    STATIC = false;
    UNICODE_INPUT = true;
    JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(ExpressionsParser)

package parser;

import ast.logic.ASTLiteral;
import ast.symbols.*;
import ast.logic.*;
import ast.types.ASTBool;
import ast.Exp;import ast.types.ASTConstant;import ast.types.ASTPred;import ast.types.ASTVariable;

public class ExpressionsParser {
}

PARSER_END(ExpressionsParser)

SKIP : {
    " "
  | "\t"
  | "\r"
  | <ENTER: "\n">
  | <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n") >
  | <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN : {
    < LPAR : "(" >
  | < RPAR : ")" >
  | < TRUE: "⊤" >
  | < FALSE: "⊥" >
  | < CMP: "≡" >
  | < NOT: "¬" >
  | < AND: "∧" >
  | < OR: "∨" >
  | < IMPLICATION: "→" >
  | < EQUIVALENT: "↔" >
  | < PREDICATE: ["A"-"Z"] (["a"-"z", "A"-"Z"])* >
  | < DEL_PREDICATE: ["A"-"Z"] (["a"-"z", "A"-"Z"])* ["/"] ["1"-"9"](["0"-"9"])*>
  | < VARIABLE: ["a"-"z"] >
  | < PERIOD : "." >
  | < COMMA : "," >
  | < UNIVERSAL: "∀" >
  | < EXISTENTIAL: "∃" >
  | < CONSTANT: (["a"-"z", "A"-"Z"])(["a"-"z", "A"-"Z"])+ >
}

/*
* Parser for propositional expressions
*/
Exp parseProp() : {
    Exp e;
} {
    e = propLogicSequences() <EOF>
    { return e; }
}

private Exp propLogicSequences() : {
    ASTSequence exps;
    Exp e;
} {
    e = propLogicEquivalences() <PERIOD> { exps = new ASTSequence(e); }
    ( e = propLogicEquivalences() <PERIOD> { exps.addExp(e); } )*
    { return exps; }
}

private Exp propLogicEquivalences() : {
    Exp e1, e2;
} {
    e1 = propLogicBinary() ( <CMP> e2 = propLogicBinary() { e1 = new ASTComp(e1, e2); } )*
    { return e1; }
}

private Exp propLogicBinary() : {
    Exp e1, e2;
} {
    e1 = propLogicUnary()
    (
        <AND> e2 = propLogicUnary() { e1 = new ASTAnd(e1, e2); }
      | <OR> e2 = propLogicUnary() { e1 = new ASTOr(e1, e2); }
      | <IMPLICATION> e2 = propLogicUnary() { e1 = new ASTImplication(e1, e2); }
      | <EQUIVALENT> e2 = propLogicUnary() { e1 = new ASTEquivalence(e1, e2); }
    )*
    { return e1; }
}

private Exp propLogicUnary() : {
    Token t;
    Exp e;
} {
    <TRUE> { return new ASTBool(true); }
  | <FALSE> { return new ASTBool(false); }
  | <NOT> e = propLogicUnary() { return new ASTNot(e); }
  | <LPAR> e = propLogicBinary() <RPAR> { return new ASTParenthesis(e); }
  | t = <VARIABLE> { return new ASTLiteral(t.image); }
}

/*
* Parser for first-order expressions
*/
Exp parseFOL() : {
    Exp e;
} {
    e = folLogicSequences() <EOF>
    { return e; }
}

private Exp folLogicSequences() : {
    ASTSequence exps;
    Exp e;
} {
    e = folLogicExpressions() <PERIOD> { exps = new ASTSequence(e); }
    ( e = folLogicExpressions() <PERIOD> { exps.addExp(e); } )*
    { return exps; }
}

private Exp folLogicExpressions() : {
    Token t;
    Exp e1, e2;
} {
    t = <DEL_PREDICATE> { return new ASTDelPred(t.image); }
    | e1 = folLogicBinary() ( <CMP> e2 = folLogicBinary() { e1 = new ASTComp(e1, e2); } )?
    { return e1; }
}

private Exp folLogicBinary() : {
    Exp e1, e2;
} {
    e1 = folLogicUnary()
    (
        <AND> e2 = folLogicUnary() { e1 = new ASTAnd(e1, e2); }
      | <OR> e2 = folLogicUnary() { e1 = new ASTOr(e1, e2); }
      | <IMPLICATION> e2 = folLogicUnary() { e1 = new ASTImplication(e1, e2); }
      | <EQUIVALENT> e2 = folLogicUnary() { e1 = new ASTEquivalence(e1, e2); }
    )*
    { return e1; }
}

//TODO I NEED TO FIND A WAY TO DECLARE TERMS BEFOREHAND likes/2.
//TODO FOR EXAMPLE: likes(a,b) expects 2 terms, but found 3 (likes(a,b,c))
private Exp folLogicUnary() : {
    Token t;
    Exp e, e1;
    ASTPred pred;
} {
    <TRUE> { return new ASTBool(true); }
  | <FALSE> { return new ASTBool(false); }
  | <NOT> e = folLogicUnary() { return new ASTNot(e); }
  | <LPAR> e = folLogicBinary() <RPAR> { return new ASTParenthesis(e); }
  | <EXISTENTIAL> e = folTerm() e1 = folLogicUnary(){ return new ASTExistential(e, e1); }
  | <UNIVERSAL> e = folTerm() e1 = folLogicUnary() { return new ASTUniversal(e, e1); }
  | t = <PREDICATE> { pred = new ASTPred(t.image); }
    <LPAR> e = folTerm() { pred.addTerm(e); } ( <COMMA> e = folTerm() { pred.addTerm(e); } )* <RPAR> {return pred; }
}

private Exp folTerm() : {
   Token t;
} {
    t = <VARIABLE> {return new ASTVariable(t.image); }
  | t = <CONSTANT> {return new ASTConstant(t.image); }
}

