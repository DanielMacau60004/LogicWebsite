options {
  STATIC=false;
  UNICODE_INPUT = true;
  JAVA_UNICODE_ESCAPE = true;
}

PARSER_BEGIN(Parser)

package parser;
import ast.*;
import ast.logic.ASTLiteral;import ast.symbols.*;
import ast.logic.*;import ast.types.ASTBool;

public class Parser {
}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
| <ENTER: "\n">
| <SINGLE_LINE_COMMENT: "//" (~["\n", "\r"])* ("\n" | "\r" | "\r\n") >
| <MULTI_LINE_COMMENT: "/*" (~["*"])* "*" (~["/"] (~["*"])* "*")* "/">
}

TOKEN :
{
  < BOOL: "bool">
  |
  < UNIT: "unit">
}

TOKEN :
{
  < LPAR : "(" >
  |
  < RPAR : ")" >
  |
  < TRUE: "⊤" >
  |
  < FALSE: "⊥" >
  |
  < CMP: "≡" >
  |
  < NOT: "¬" >
  |
  < AND: "∧" >
  |
  < OR: "∨" >
  |
  <IMPLICATION: "→">
  |
  <EQUIVALENT: "↔">
  |
  < LITERAL: ["a"-"z"] >
  |
  <PERIOD : ".">
}

Exp Start():
{ Exp e; }
{
   e = Sequences() <EOF>
   {return e;}
}

Exp Sequences():
{ ASTSequence exps; Exp e; }
{
   e = Cmp() <PERIOD> {exps = new ASTSequence(e);} ( e = Cmp() <PERIOD> {exps.addExp(e);})*
   {return exps;}
}

Exp Cmp() :
{ Token t; Exp e1, e2, e3;}
{
   e1 = Pred() (t = <CMP> e2 = Pred() {e1 = new ASTComp(t,e1,e2);})*
   { return e1; }
}

Exp Pred() :
{ Token t; Exp e1, e2; }
{
   e1 = Fact()
   (
       t =<AND> e2 = Fact() {e1 = new ASTAnd(t, e1,e2);}
       | t = <OR> e2 = Fact() {e1 = new ASTOr(t, e1,e2);}
       | t = <IMPLICATION> e2 = Fact() {e1 = new ASTImplication(t,e1,e2);}
       | t = <EQUIVALENT> e2 = Fact() {e1 = new ASTEquivalence(t,e1,e2);}
   )*
   { return e1; }

}

Exp Fact() :
{ Token t, t1;  Exp e;}
{
 t = <TRUE> { return new ASTBool(t, true); }
 | t = <FALSE> { return new ASTBool(t, false); }
 | t = <NOT> e = Fact() {return new ASTNot(t, e);}
 | t = <LPAR> e = Pred() t1 = <RPAR> {return new ASTParenthesis(t, t1, e);}
 | t = <LITERAL> {return new ASTLiteral(t, token.image);}
}


